<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cuestionario Interactivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para drag and drop (arrastrar y soltar) */
        .draggable {
            cursor: grab;
            user-select: none; /* Previene la selección de texto al arrastrar */
            transition: opacity 0.2s ease; /* Transición suave para la visibilidad */
            touch-action: none; /* Para compatibilidad con eventos táctiles */
        }

        .dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .drop-zone {
            border: 2px dashed #ccc;
            min-height: 50px;
            transition: background-color 0.3s ease, border-color 0.3s ease; /* Transición de borde añadida */
            display: flex; /* Usa flexbox para alinear */
            align-items: center; /* Centra ítems verticalmente */
            padding: 0.75rem; /* Usa padding p-3 de Tailwind */
            position: relative; /* Para posicionar el placeholder */
        }

        .drag-over {
            background-color: #e0e0e0;
            border-color: #aaa;
        }

        .matched {
            background-color: #d1fae5; /* Fondo verde claro */
            border: 1px solid #059669; /* Borde verde */
        }

        .feedback-correct { color: #059669; /* Verde */ }
        .feedback-incorrect { color: #dc2626; /* Rojo */ }

        /* Estilo para respuestas correctas/incorrectas */
        .correct-answer { background-color: #d1fae5 !important; border: 1px solid #059669; }
        .incorrect-answer { background-color: #fee2e2 !important; border: 1px solid #dc2626; }

        /* Estilo para opciones marcadas (no usado directamente en JS ahora, pero útil) */
        .correct-choice::after { content: ' ✔️'; color: green; }
        .incorrect-choice::after { content: ' ❌'; color: red; }

        .correct-match-feedback { color: green; font-weight: bold; }
        .incorrect-match-feedback { color: red; font-weight: bold; }

        /* Asegura que el ítem soltado ocupe espacio */
        .drop-zone .draggable { margin-left: 0.5rem; /* Espacio entre definición y término */ }

        /* Oculta el placeholder cuando hay un match */
        .matched .placeholder-text { display: none; }

        /* Estilos para las pestañas */
        .tab-button {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 0.375rem 0.375rem 0 0; /* rounded-t-md */
            background-color: #e5e7eb; /* bg-gray-200 */
            color: #4b5563; /* text-gray-600 */
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .tab-button:hover {
            background-color: #d1d5db; /* bg-gray-300 */
        }
        .tab-button.active {
            background-color: #ffffff; /* bg-white */
            color: #1f2937; /* text-gray-800 */
            border-color: #d1d5db; /* border-gray-300 */
            font-weight: 600; /* font-semibold */
        }
        .tab-content {
            display: none; /* Oculto por defecto */
            border: 1px solid #d1d5db; /* border-gray-300 */
            border-top: none;
            padding: 1.5rem; /* p-6 */
            background-color: #ffffff; /* bg-white */
            border-radius: 0 0 0.375rem 0.375rem; /* rounded-b-md */
        }
        .tab-content.active {
            display: block; /* Mostrar contenido activo */
        }

        /* Estilo para el editor JSON */
        #json-editor {
            font-family: monospace;
            min-height: 400px;
            border: 1px solid #d1d5db;
            padding: 0.75rem;
            border-radius: 0.375rem;
            width: 100%;
            box-sizing: border-box; /* Incluye padding y borde en el ancho */
        }
         /* Estilo para la sección de ayuda */
        #explanation-content pre {
            background-color: #f3f4f6; /* bg-gray-100 */
            padding: 1rem;
            border-radius: 0.375rem; /* rounded-md */
            overflow-x: auto; /* Scroll horizontal si es necesario */
            white-space: pre-wrap; /* Mantiene saltos de línea */
            word-wrap: break-word;
        }
        #explanation-content h2 { font-size: 1.5rem; font-weight: 600; margin-top: 1rem; margin-bottom: 0.5rem;}
        #explanation-content h3 { font-size: 1.25rem; font-weight: 600; margin-top: 0.8rem; margin-bottom: 0.4rem;}
        #explanation-content ul { list-style: disc; margin-left: 1.5rem; margin-bottom: 0.5rem;}
        #explanation-content code { background-color: #e5e7eb; padding: 0.1rem 0.3rem; border-radius: 0.25rem; font-family: monospace;}
        #explanation-content pre > code { background-color: transparent; padding: 0; border-radius: 0; } /* Reset para code dentro de pre */

    </style>
</head>

<body class="bg-gray-100 font-sans p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white p-6 md:p-10 rounded-lg shadow-lg">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800 mb-6">Cuestionario Interactivo</h1>

        <div class="mb-6">
            <div class="flex border-b border-gray-300">
                <button class="tab-button active" data-tab="quiz">Cuestionario</button>
                <button class="tab-button" data-tab="editor">Editar Preguntas (JSON)</button>
                <button class="tab-button" data-tab="explanation">Ayuda / README</button>
            </div>

            <div id="quiz-tab" class="tab-content active">
                <form id="quiz-form">
                    <div id="quiz-container" class="space-y-8">
                        <p class="text-center text-gray-500">Cargando preguntas...</p>
                    </div>

                    <div class="mt-10 text-center">
                        <button type="submit"
                            class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg transition duration-300">
                            Enviar Respuestas
                        </button>
                    </div>
                </form>

                <div id="results-container" class="mt-10 p-6 bg-gray-50 rounded-lg hidden">
                    <h2 class="text-xl font-semibold text-center mb-4">Resultados</h2>
                    <p id="score" class="text-center text-lg font-bold mb-6"></p>
                    <div id="feedback" class="space-y-4"></div>
                    <div class="mt-6 text-center">
                        <button id="retry-button"
                            class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded-lg transition duration-300">
                            Intentar de Nuevo
                        </button>
                    </div>
                </div>
            </div>

            <div id="editor-tab" class="tab-content">
                <h2 class="text-xl font-semibold mb-4">Editor de Preguntas (JSON)</h2>
                <p class="text-sm text-gray-600 mb-4">
                    Modifica el JSON a continuación para cambiar las preguntas del cuestionario. Los cambios se guardarán en el almacenamiento local de tu navegador.
                    Asegúrate de que el formato JSON sea válido antes de guardar.
                </p>
                <textarea id="json-editor" spellcheck="false"></textarea>
                <div class="mt-4 flex justify-between items-center">
                    <button id="save-json-button"
                        class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition duration-300">
                        Guardar Cambios
                    </button>
                    <span id="save-status" class="text-sm"></span>
                </div>
                 <div class="mt-4">
                     <button id="reset-json-button"
                        class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg transition duration-300 text-sm">
                        Restablecer Preguntas Predeterminadas
                    </button>
                     <p class="text-xs text-gray-500 mt-1">Esto eliminará tus cambios y volverá a las preguntas originales.</p>
                </div>
            </div>

            <div id="explanation-tab" class="tab-content">
                 <h2 class="text-xl font-semibold mb-4">Ayuda / README</h2>
                 <div id="explanation-content">
                     <p class="text-center text-gray-500">Cargando ayuda...</p>
                 </div>
            </div>
        </div>
    </div>

    <script>
        // --- Default Quiz Data (Fallback) ---
        // This data is used if localStorage is empty or invalid
        const defaultQuizData = [
            // --- Sección 1: Introducción y Conceptos Básicos ---
            // 1. Conceptos Básicos (Matching) - EXISTENTE
            {
                type: 'matching',
                question: 'Une cada concepto básico de seguridad con su definición:',
                terms: [
                    'Activo',
                    'Amenaza',
                    'Vulnerabilidad',
                    'Riesgo',
                    'Control'
                ],
                definitions: [
                    'Recurso valioso que necesita protección.',
                    'Evento o acción potencial que puede causar daño.',
                    'Debilidad o fallo en un sistema que puede ser explotado.',
                    'Probabilidad de que una amenaza explote una vulnerabilidad.',
                    'Medida de seguridad implementada para reducir o mitigar riesgos.'
                ],
                correctMatches: {
                    'Activo': 'Recurso valioso que necesita protección.',
                    'Amenaza': 'Evento o acción potencial que puede causar daño.',
                    'Vulnerabilidad': 'Debilidad o fallo en un sistema que puede ser explotado.',
                    'Riesgo': 'Probabilidad de que una amenaza explote una vulnerabilidad.',
                    'Control': 'Medida de seguridad implementada para reducir o mitigar riesgos.'
                }
            },
            // 2. Evento vs Incidente (Single Choice) - EXISTENTE
            {
                type: 'single',
                question: 'Según ISO 27035, ¿qué diferencia principalmente un Incidente de Seguridad de un Evento de Seguridad?',
                options: [
                    'Un evento siempre es malicioso, un incidente no.',
                    'Un incidente tiene una probabilidad significativa de comprometer operaciones o amenazar la seguridad.',
                    'Un evento requiere una respuesta inmediata, un incidente no.',
                    'Un incidente es siempre causado por un atacante externo.'
                ],
                correctAnswer: 'Un incidente tiene una probabilidad significativa de comprometer operaciones o amenazar la seguridad.'
            },
             // ... (El resto de las preguntas predeterminadas van aquí) ...
             // Añadí solo las dos primeras para brevedad, pero aquí iría el array completo original.
            {
                type: 'single',
                question: '¿Cuál es el objetivo principal de un CSIRT según los documentos?',
                options: [
                    'Desarrollar software de seguridad',
                    'Proteger infraestructuras críticas de la información',
                    'Vender productos antivirus',
                    'Realizar auditorías financieras'
                ],
                correctAnswer: 'Proteger infraestructuras críticas de la información'
            },
            {
                type: 'single',
                question: 'Según la norma ISO 27035, ¿qué es un Evento de Seguridad?',
                options: [
                    'Un ataque exitoso confirmado',
                    'Una ocurrencia identificada que indica una posible violación de seguridad o fallo de control',
                    'Cualquier correo electrónico recibido',
                    'Una actualización de software'
                ],
                correctAnswer: 'Una ocurrencia identificada que indica una posible violación de seguridad o fallo de control'
            },
            {
                type: 'matching',
                question: 'Une cada término con su definición correcta:',
                terms: [
                    'Amenaza',
                    'Vulnerabilidad',
                    'Riesgo',
                    'Control'
                ],
                definitions: [
                    'Debilidad o fallo en un sistema que puede ser explotado.',
                    'Medida de seguridad implementada para reducir riesgos.',
                    'Evento o acción que puede causar daño.',
                    'Probabilidad de que una amenaza explote una vulnerabilidad.'
                ],
                correctMatches: {
                    'Amenaza': 'Evento o acción que puede causar daño.',
                    'Vulnerabilidad': 'Debilidad o fallo en un sistema que puede ser explotado.',
                    'Riesgo': 'Probabilidad de que una amenaza explote una vulnerabilidad.',
                    'Control': 'Medida de seguridad implementada para reducir riesgos.'
                }
            },
        ];

        // --- README Content (para la pestaña de Ayuda) ---
        // Contenido extraído del archivo README.md
        const readmeContent = `
# Cuestionario Interactivo de Ciberseguridad

Este es un simple cuestionario interactivo creado con HTML, CSS (Tailwind) y JavaScript. Permite presentar preguntas de opción única, opción múltiple y de unir conceptos. Ahora también permite editar las preguntas directamente en el navegador.

## Características

- Preguntas de opción única
- Preguntas de opción múltiple
- Preguntas de unir conceptos (arrastrar y soltar)
- Barajado aleatorio de preguntas y opciones/términos
- Retroalimentación instantánea al enviar
- Puntuación final
- **Edición de Preguntas**: Modifica y guarda las preguntas (formato JSON) usando la pestaña "Editar Preguntas". Los cambios se guardan en el almacenamiento local de tu navegador.
- **Ayuda Integrada**: Esta sección explica cómo funciona todo.

## Cómo Usar

1.  **Navegar por Pestañas**: Usa los botones en la parte superior ("Cuestionario", "Editar Preguntas", "Ayuda / README") para cambiar de sección.
2.  **Responder el Cuestionario**: En la pestaña "Cuestionario", responde las preguntas. Para las de unir, arrastra los términos azules a las definiciones correspondientes. Haz clic en "Enviar Respuestas" al finalizar.
3.  **Ver Resultados**: Se mostrará tu puntuación y la retroalimentación detallada para cada pregunta.
4.  **Reintentar**: Puedes usar el botón "Intentar de Nuevo" para volver a realizar el cuestionario con las preguntas actuales (se barajarán de nuevo).
5.  **Editar Preguntas**:
    * Ve a la pestaña "Editar Preguntas".
    * Verás las preguntas actuales en formato JSON.
    * Puedes modificar el texto, añadir nuevas preguntas (copiando y pegando la estructura de una existente y cambiando los datos), o eliminar preguntas. **¡Cuidado con la sintaxis JSON!** Comas, llaves \`{}\`, corchetes \`[]\` y comillas dobles \`""\` son importantes.
    * Haz clic en "Guardar Cambios" para almacenar las preguntas modificadas en tu navegador. Un mensaje indicará si se guardó correctamente o si hubo un error en el formato JSON.
    * Si quieres volver a las preguntas originales, usa el botón "Restablecer Preguntas Predeterminadas".
    * **Nota**: Los cambios se guardan *solo en tu navegador*. No afectan al archivo original.

## Formato JSON de Preguntas

Las preguntas se definen como un array de objetos JSON. Cada objeto representa una pregunta y debe tener las siguientes claves:

-   \`type\`: Tipo de pregunta ('single', 'multiple', 'matching').
-   \`question\`: El texto de la pregunta (string).

### Tipo 'single' (Opción Única)

-   \`options\`: Un array de strings con las posibles respuestas.
-   \`correctAnswer\`: El string exacto de la respuesta correcta.

\`\`\`json
{
    "type": "single",
    "question": "¿Pregunta de opción única?",
    "options": ["Opción A", "Opción B", "Respuesta Correcta"],
    "correctAnswer": "Respuesta Correcta"
}
\`\`\`

### Tipo 'multiple' (Opción Múltiple)

-   \`options\`: Un array de strings con las posibles respuestas.
-   \`correctAnswers\`: Un array de strings con *todas* las respuestas correctas.

\`\`\`json
{
    "type": "multiple",
    "question": "¿Pregunta de selección múltiple?",
    "options": ["Opción A", "Opción Correcta 1", "Opción Correcta 2", "Opción D"],
    "correctAnswers": ["Opción Correcta 1", "Opción Correcta 2"]
}
\`\`\`

### Tipo 'matching' (Unir Conceptos)

-   \`terms\`: Un array de strings con los términos a arrastrar.
-   \`definitions\`: Un array de strings con las definiciones (zonas para soltar).
-   \`correctMatches\`: Un objeto donde cada clave es un término y su valor es la definición correcta correspondiente.

\`\`\`json
{
    "type": "matching",
    "question": "Une los conceptos relacionados",
    "terms": ["Término A", "Término B", "Término C"],
    "definitions": ["Definición A", "Definición B", "Definición C"],
    "correctMatches": {
        "Término A": "Definición A",
        "Término B": "Definición B",
        "Término C": "Definición C"
    }
}
\`\`\`
        `;


        // --- DOM Elements ---
        const quizContainer = document.getElementById('quiz-container');
        const quizForm = document.getElementById('quiz-form');
        const resultsContainer = document.getElementById('results-container');
        const scoreElement = document.getElementById('score');
        const feedbackElement = document.getElementById('feedback');
        const retryButton = document.getElementById('retry-button');
        const jsonEditor = document.getElementById('json-editor');
        const saveJsonButton = document.getElementById('save-json-button');
        const resetJsonButton = document.getElementById('reset-json-button');
        const saveStatus = document.getElementById('save-status');
        const explanationContent = document.getElementById('explanation-content');
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // --- Global Variables ---
        let currentQuizData = []; // Holds the questions currently being used
        let draggedItem = null;
        let sourceContainer = null; // To remember where the item came from

        // --- Functions ---

        // Function to shuffle array elements (Fisher-Yates shuffle)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Function to load quiz questions from localStorage or defaults
        function loadQuizData() {
            const storedData = localStorage.getItem('quizData');
            let loadedData = null;
            if (storedData) {
                try {
                    loadedData = JSON.parse(storedData);
                    // Basic validation: check if it's an array and not empty
                    if (!Array.isArray(loadedData) || loadedData.length === 0) {
                        console.warn("Stored quiz data is invalid or empty. Using default data.");
                        loadedData = null; // Force using default
                    }
                } catch (error) {
                    console.error("Error parsing quiz data from localStorage:", error);
                    loadedData = null; // Force using default on error
                }
            }

            if (loadedData) {
                currentQuizData = loadedData;
                console.log("Loaded quiz data from localStorage.");
            } else {
                currentQuizData = defaultQuizData;
                console.log("Using default quiz data.");
                // Save default data to localStorage if it wasn't there initially
                if (!storedData) {
                    try {
                        localStorage.setItem('quizData', JSON.stringify(defaultQuizData, null, 2));
                        console.log("Saved default quiz data to localStorage.");
                    } catch (error) {
                         console.error("Error saving default quiz data to localStorage:", error);
                    }
                }
            }
            // Update the JSON editor content
            updateJsonEditor();
        }

        // Function to update the JSON editor textarea
        function updateJsonEditor() {
             try {
                jsonEditor.value = JSON.stringify(currentQuizData, null, 2); // Pretty print
            } catch (error) {
                console.error("Error stringifying quiz data for editor:", error);
                jsonEditor.value = "Error: No se pudieron cargar las preguntas en el editor.";
            }
        }

        // Function to load quiz questions into the DOM UI
        function loadQuizUI() {
            quizContainer.innerHTML = ''; // Clear previous questions
            resultsContainer.classList.add('hidden'); // Hide results
            quizForm.reset(); // Reset form inputs
            // Reset previous feedback styles
            document.querySelectorAll('.correct-answer, .incorrect-answer').forEach(el => {
                el.classList.remove('correct-answer', 'incorrect-answer');
            });
             document.querySelectorAll('.drop-zone').forEach(zone => {
                zone.classList.remove('correct-answer', 'incorrect-answer', 'matched');
                const placeholder = zone.querySelector('.placeholder-text');
                if (placeholder) placeholder.style.display = 'inline'; // Show placeholder
            });
            feedbackElement.innerHTML = ''; // Clear previous feedback

            // Re-enable submit button if it was disabled
            const submitButton = quizForm.querySelector('button[type="submit"]');
            if (submitButton) {
                 submitButton.disabled = false;
                 submitButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }


            if (!currentQuizData || currentQuizData.length === 0) {
                 quizContainer.innerHTML = '<p class="text-center text-red-600 font-semibold">No se encontraron preguntas. Intenta restablecerlas en la pestaña de edición.</p>';
                 if (submitButton) submitButton.disabled = true; // Disable submit if no questions
                 return;
            }


            currentQuizData.forEach((qData, index) => {
                // Validate question structure minimally
                if (!qData || !qData.type || !qData.question) {
                    console.warn(`Skipping invalid question data at index ${index}:`, qData);
                    const errorDiv = document.createElement('div');
                    errorDiv.classList.add('bg-red-100', 'p-4', 'rounded-lg', 'shadow', 'text-red-700');
                    errorDiv.textContent = `Error: Pregunta ${index + 1} tiene un formato inválido y no se puede mostrar. Revísala en el editor.`;
                    quizContainer.appendChild(errorDiv);
                    return; // Skip this iteration
                }

                const questionDiv = document.createElement('div');
                questionDiv.classList.add('bg-white', 'p-6', 'rounded-lg', 'shadow');
                questionDiv.setAttribute('data-question-index', index); // Store original index

                const questionTitle = document.createElement('h3');
                questionTitle.classList.add('text-lg', 'font-semibold', 'mb-4', 'text-gray-700');
                questionTitle.textContent = `Pregunta ${index + 1}: ${qData.question}`;
                questionDiv.appendChild(questionTitle);

                const optionsContainer = document.createElement('div');


                if (qData.type === 'single' || qData.type === 'multiple') {
                    if (!qData.options || !Array.isArray(qData.options)) {
                         console.warn(`Skipping invalid options for question ${index}:`, qData);
                         optionsContainer.innerHTML = `<p class="text-red-500 text-sm">Error: Opciones inválidas.</p>`;
                    } else {
                        optionsContainer.classList.add('space-y-3'); // Add spacing for radio/checkbox
                        const inputType = qData.type === 'single' ? 'radio' : 'checkbox';
                        shuffleArray([...qData.options]).forEach(option => {
                            const label = document.createElement('label');
                            label.classList.add('flex', 'items-center', 'p-3', 'border', 'rounded-md', 'hover:bg-gray-50', 'transition', 'duration-150', 'cursor-pointer');

                            const input = document.createElement('input');
                            input.type = inputType;
                            input.name = `question_${index}`;
                            input.value = option;
                            input.classList.add('mr-3', 'h-4', 'w-4', inputType === 'radio' ? 'text-blue-600' : 'text-blue-600', 'focus:ring-blue-500', 'border-gray-300');

                            const span = document.createElement('span');
                            span.textContent = option;
                            span.classList.add('text-gray-800');

                            label.appendChild(input);
                            label.appendChild(span);
                            optionsContainer.appendChild(label);
                        });
                    }
                } else if (qData.type === 'matching') {
                     if (!qData.terms || !Array.isArray(qData.terms) || !qData.definitions || !Array.isArray(qData.definitions) || !qData.correctMatches || typeof qData.correctMatches !== 'object') {
                         console.warn(`Skipping invalid matching data for question ${index}:`, qData);
                         optionsContainer.innerHTML = `<p class="text-red-500 text-sm">Error: Datos de emparejamiento inválidos.</p>`;
                     } else {
                        optionsContainer.classList.add('grid', 'grid-cols-1', 'md:grid-cols-2', 'gap-6'); // Grid layout for matching

                        const termsDiv = document.createElement('div');
                        termsDiv.classList.add('space-y-3', 'terms-container-js'); // Added class for easy selection
                        const termsTitle = document.createElement('h4');
                        termsTitle.textContent = 'Términos (Arrastra desde aquí)';
                        termsTitle.classList.add('font-medium', 'text-gray-600', 'mb-2');
                        termsDiv.appendChild(termsTitle);

                        const shuffledTerms = shuffleArray([...qData.terms]);
                        shuffledTerms.forEach(term => {
                            const termElement = document.createElement('div');
                            termElement.textContent = term;
                            termElement.classList.add('p-3', 'bg-blue-100', 'border', 'border-blue-300', 'rounded-md', 'draggable');
                            termElement.draggable = true;
                            // Use a more robust ID including the index
                            termElement.id = `term_${index}_${term.replace(/[^a-zA-Z0-9]/g, '_')}`; // Sanitize ID
                            termElement.addEventListener('dragstart', handleDragStart);
                            termElement.addEventListener('dragend', handleDragEnd); // Add dragend listener here
                            // Add touch events for mobile drag-and-drop simulation
                            termElement.addEventListener('touchstart', handleTouchStart, { passive: false }); // Need passive false to prevent scroll
                            termElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                            termElement.addEventListener('touchend', handleTouchEnd);

                            termsDiv.appendChild(termElement);
                        });

                        const definitionsDiv = document.createElement('div');
                        definitionsDiv.classList.add('space-y-3');
                        const definitionsTitle = document.createElement('h4');
                        definitionsTitle.textContent = 'Definiciones (Suelta aquí)';
                        definitionsTitle.classList.add('font-medium', 'text-gray-600', 'mb-2');
                        definitionsDiv.appendChild(definitionsTitle);

                        const shuffledDefinitions = shuffleArray([...qData.definitions]);
                        shuffledDefinitions.forEach(definition => {
                            const dropZone = document.createElement('div');
                            // Added flex, items-center, justify-between
                            dropZone.classList.add('border', 'border-gray-300', 'rounded-md', 'drop-zone');
                            dropZone.dataset.definition = definition;
                            dropZone.addEventListener('dragover', handleDragOver);
                            dropZone.addEventListener('dragleave', handleDragLeave);
                            dropZone.addEventListener('drop', handleDrop);
                             // Add touch event listeners for drop zones
                            // Note: Touch events don't have direct equivalents for dragover/dragleave/drop
                            // We'll handle logic within touchmove and touchend on the draggable item

                            const definitionText = document.createElement('span');
                            definitionText.textContent = definition;
                            definitionText.classList.add('text-gray-800', 'mr-2', 'flex-grow'); // Allow text to take space
                            dropZone.appendChild(definitionText);

                            // Placeholder text (initially visible)
                            const placeholder = document.createElement('span');
                            placeholder.classList.add('text-gray-400', 'italic', 'text-sm', 'placeholder-text');
                            placeholder.textContent = '(Arrastra aquí)';
                            dropZone.appendChild(placeholder);


                            definitionsDiv.appendChild(dropZone);
                        });

                        optionsContainer.appendChild(termsDiv);
                        optionsContainer.appendChild(definitionsDiv);
                    }
                } else {
                     console.warn(`Skipping unknown question type at index ${index}:`, qData.type);
                     optionsContainer.innerHTML = `<p class="text-orange-500 text-sm">Error: Tipo de pregunta desconocido "${qData.type}".</p>`;
                }

                questionDiv.appendChild(optionsContainer);
                quizContainer.appendChild(questionDiv);
            });
        }

        // --- Drag and Drop Handlers (Mouse) ---
        function handleDragStart(e) {
            if (!e.target.classList.contains('draggable')) return;

            draggedItem = e.target;
            sourceContainer = e.target.parentElement;
            e.dataTransfer.setData('text/plain', e.target.id);
            e.dataTransfer.effectAllowed = 'move';

            setTimeout(() => {
                if (draggedItem) {
                    draggedItem.classList.add('dragging');
                }
            }, 0);

            if (sourceContainer.classList.contains('drop-zone')) {
                sourceContainer.classList.remove('matched');
                const placeholder = sourceContainer.querySelector('.placeholder-text');
                if (placeholder) placeholder.style.display = 'inline';
            }
        }

        function handleDragEnd(e) {
            if (!draggedItem) return;

            // Check if the item was successfully dropped (parent changed or still in a valid drop zone)
            const successfullyDropped = draggedItem.parentElement.classList.contains('drop-zone') ||
                                        (sourceContainer && draggedItem.parentElement !== sourceContainer);

            // If drop failed or was cancelled, attempt to return to original terms list
            if (!successfullyDropped && sourceContainer && !sourceContainer.classList.contains('drop-zone')) {
                 // It started in the terms list and wasn't dropped in a zone
                 sourceContainer.appendChild(draggedItem); // Put it back
            } else if (!successfullyDropped && sourceContainer && sourceContainer.classList.contains('drop-zone')) {
                 // It started in a drop zone but wasn't dropped in another valid one
                 // Find the original terms list for this question
                 const questionElement = sourceContainer.closest('[data-question-index]');
                 const originalTermsContainer = questionElement?.querySelector('.terms-container-js');
                 if (originalTermsContainer) {
                     sourceContainer.removeChild(draggedItem); // Remove from invalid drop zone
                     sourceContainer.classList.remove('matched');
                     const placeholder = sourceContainer.querySelector('.placeholder-text');
                     if (placeholder) placeholder.style.display = 'inline';
                     originalTermsContainer.appendChild(draggedItem); // Return to terms list
                 }
            }


            // Always restore appearance and reset global variables
            draggedItem.classList.remove('dragging'); // Use class for opacity now
            draggedItem = null;
            sourceContainer = null;

            // Remove any lingering drag-over styles
            document.querySelectorAll('.drag-over').forEach(zone => zone.classList.remove('drag-over'));
        }


        function handleDragOver(e) {
            e.preventDefault();
            const targetZone = e.target.closest('.drop-zone');
            if (targetZone && !targetZone.querySelector('.draggable')) { // Only allow drop if zone is empty
                targetZone.classList.add('drag-over');
                e.dataTransfer.dropEffect = 'move';
            } else {
                 document.querySelectorAll('.drag-over').forEach(zone => zone.classList.remove('drag-over')); // Clear others
                 if (targetZone) targetZone.classList.add('drag-over'); // Highlight current target
                 e.dataTransfer.dropEffect = 'none';
            }
        }

        function handleDragLeave(e) {
            const targetZone = e.target.closest('.drop-zone');
            if (targetZone && e.relatedTarget && !targetZone.contains(e.relatedTarget)) {
                 // Only remove if leaving the zone entirely, not just moving over child elements
                targetZone.classList.remove('drag-over');
            } else if (!e.relatedTarget && targetZone) {
                 // Handles leaving the window or iframe boundary
                 targetZone.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetZone = e.target.closest('.drop-zone');

            if (draggedItem && targetZone && !targetZone.querySelector('.draggable')) { // Only drop if zone is empty
                targetZone.classList.remove('drag-over');

                const placeholder = targetZone.querySelector('.placeholder-text');
                if (placeholder) placeholder.style.display = 'none';

                // If the item came from another drop zone, handle cleanup there
                if (sourceContainer && sourceContainer.classList.contains('drop-zone') && sourceContainer !== targetZone) {
                    sourceContainer.removeChild(draggedItem);
                    sourceContainer.classList.remove('matched');
                    const oldPlaceholder = sourceContainer.querySelector('.placeholder-text');
                    if (oldPlaceholder) oldPlaceholder.style.display = 'inline';
                }

                targetZone.appendChild(draggedItem);
                targetZone.classList.add('matched');

                // Final state is set in handleDragEnd
            } else if (targetZone) {
                 // Drop failed (e.g., zone not empty)
                 targetZone.classList.remove('drag-over');
                 // handleDragEnd will attempt to return the item
            }
        }

        // --- Touch Event Handlers (Mobile Drag Simulation) ---
        let touchStartX, touchStartY;
        let currentDropTarget = null;
        let clone = null; // Clone for visual feedback

        function handleTouchStart(e) {
            if (!e.target.classList.contains('draggable')) return;
            e.preventDefault(); // Prevent scrolling while dragging

            draggedItem = e.target;
            sourceContainer = draggedItem.parentElement;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;

            // Create a visual clone to drag around
            clone = draggedItem.cloneNode(true);
            clone.style.position = 'absolute';
            clone.style.zIndex = '1000';
            clone.style.opacity = '0.7';
            clone.style.pointerEvents = 'none'; // Don't let the clone interfere with finding drop targets
            clone.style.left = `${touch.clientX - draggedItem.offsetWidth / 2}px`;
            clone.style.top = `${touch.clientY - draggedItem.offsetHeight / 2}px`;
            document.body.appendChild(clone);

            draggedItem.classList.add('dragging'); // Style original item

             if (sourceContainer.classList.contains('drop-zone')) {
                sourceContainer.classList.remove('matched');
                const placeholder = sourceContainer.querySelector('.placeholder-text');
                if (placeholder) placeholder.style.display = 'inline';
            }
        }

        function handleTouchMove(e) {
            if (!draggedItem || !clone) return;
            e.preventDefault(); // Prevent scrolling

            const touch = e.touches[0];
            const currentX = touch.clientX;
            const currentY = touch.clientY;

            // Move the clone
            clone.style.left = `${currentX - clone.offsetWidth / 2}px`;
            clone.style.top = `${currentY - clone.offsetHeight / 2}px`;

            // Find the element under the touch point
            clone.style.visibility = 'hidden'; // Hide clone temporarily to find element underneath
            const elementUnderTouch = document.elementFromPoint(currentX, currentY);
            clone.style.visibility = 'visible'; // Show clone again

            const potentialDropTarget = elementUnderTouch ? elementUnderTouch.closest('.drop-zone') : null;

            // Remove previous hover effect if not over a valid target anymore
            if (currentDropTarget && currentDropTarget !== potentialDropTarget) {
                currentDropTarget.classList.remove('drag-over');
            }

            // Add hover effect to new target if valid and empty
            if (potentialDropTarget && !potentialDropTarget.querySelector('.draggable')) {
                potentialDropTarget.classList.add('drag-over');
                currentDropTarget = potentialDropTarget;
            } else {
                currentDropTarget = null; // Not over a valid, empty drop zone
            }
        }

        function handleTouchEnd(e) {
            if (!draggedItem || !clone) return;

            // Remove the visual clone
            document.body.removeChild(clone);
            clone = null;

            // Remove lingering hover effects
             if (currentDropTarget) {
                 currentDropTarget.classList.remove('drag-over');
             }

            // Perform the drop if over a valid target
            if (currentDropTarget && !currentDropTarget.querySelector('.draggable')) { // Check again if empty
                 const targetZone = currentDropTarget;

                 const placeholder = targetZone.querySelector('.placeholder-text');
                 if (placeholder) placeholder.style.display = 'none';

                 // Cleanup source if it was another drop zone
                 if (sourceContainer && sourceContainer.classList.contains('drop-zone') && sourceContainer !== targetZone) {
                     sourceContainer.removeChild(draggedItem);
                     sourceContainer.classList.remove('matched');
                     const oldPlaceholder = sourceContainer.querySelector('.placeholder-text');
                     if (oldPlaceholder) oldPlaceholder.style.display = 'inline';
                 }

                 targetZone.appendChild(draggedItem);
                 targetZone.classList.add('matched');
                 draggedItem.classList.remove('dragging'); // Restore original item style
            } else {
                 // Touch ended outside a valid drop zone, return to source if needed
                 if (sourceContainer && !sourceContainer.contains(draggedItem)) {
                     // If it was moved from its original container (e.g., from a drop zone)
                     // and not dropped successfully, return it to the terms list.
                     const questionElement = sourceContainer.closest('[data-question-index]') ?? draggedItem.closest('[data-question-index]');
                     const originalTermsContainer = questionElement?.querySelector('.terms-container-js');

                     if (sourceContainer.classList.contains('drop-zone')) {
                         sourceContainer.removeChild(draggedItem); // Remove from invalid drop zone attempt
                         sourceContainer.classList.remove('matched');
                         const placeholder = sourceContainer.querySelector('.placeholder-text');
                         if (placeholder) placeholder.style.display = 'inline';
                     }

                     if (originalTermsContainer) {
                         originalTermsContainer.appendChild(draggedItem); // Append back to the original terms list
                     }
                 }
                 draggedItem.classList.remove('dragging'); // Restore original item style even if returned
            }

            // Reset global state
            draggedItem = null;
            sourceContainer = null;
            currentDropTarget = null;
        }


        // Function to calculate score and show results
        function showResults() {
            let score = 0;
            let totalQuestions = currentQuizData.length;
            feedbackElement.innerHTML = ''; // Clear previous feedback

            if (totalQuestions === 0) {
                 scoreElement.textContent = "No hay preguntas para evaluar.";
                 resultsContainer.classList.remove('hidden');
                 return;
            }


            currentQuizData.forEach((qData, index) => {
                const questionElement = quizContainer.children[index];
                // If the question element is an error message, skip evaluation
                if (!questionElement || !questionElement.dataset.questionIndex) {
                     // Maybe add a note in feedback? For now, just skip.
                     console.log(`Skipping evaluation for invalid question element at index ${index}`);
                     totalQuestions--; // Adjust total if a question couldn't be displayed/evaluated
                     return;
                }


                const feedbackDiv = document.createElement('div');
                feedbackDiv.classList.add('p-4', 'border', 'rounded-md', 'mb-4');
                const questionTitle = document.createElement('p');
                questionTitle.classList.add('font-semibold', 'mb-2');
                questionTitle.textContent = `Pregunta ${index + 1}: ${qData.question}`;
                feedbackDiv.appendChild(questionTitle);

                let isCorrect = false;
                let isAnswered = false; // Track if the question was attempted

                try { // Add try-catch around each question type evaluation
                    if (qData.type === 'single') {
                        const selectedOption = quizForm.querySelector(`input[name="question_${index}"]:checked`);
                        const options = questionElement.querySelectorAll(`input[name="question_${index}"]`);
                        isAnswered = !!selectedOption; // True if an option was selected

                        options.forEach(optionInput => {
                            const label = optionInput.closest('label');
                            if (!label) return; // Skip if structure is broken
                            // Reset previous styles
                            label.classList.remove('correct-answer', 'incorrect-answer');
                            if (optionInput.value === qData.correctAnswer) {
                                label.classList.add('correct-answer'); // Always highlight correct answer
                                if (selectedOption && selectedOption.value === optionInput.value) {
                                    isCorrect = true;
                                }
                            } else if (selectedOption && selectedOption.value === optionInput.value) {
                                label.classList.add('incorrect-answer'); // Highlight incorrect selection
                            }
                            // Disable input after submission
                            optionInput.disabled = true;
                        });

                        const feedbackText = document.createElement('p');
                        if (isAnswered) {
                            if (isCorrect) {
                                feedbackText.textContent = '¡Correcto!';
                                feedbackText.classList.add('feedback-correct');
                                score++;
                            } else {
                                feedbackText.textContent = `Incorrecto. La respuesta correcta es: ${qData.correctAnswer}`;
                                feedbackText.classList.add('feedback-incorrect');
                            }
                            feedbackDiv.classList.add(isCorrect ? 'bg-green-50' : 'bg-red-50');
                        } else {
                            feedbackText.textContent = `No respondida. La respuesta correcta es: ${qData.correctAnswer}`;
                            feedbackText.classList.add('feedback-incorrect');
                            feedbackDiv.classList.add('bg-yellow-50'); // Indicate unanswered
                        }
                        feedbackDiv.appendChild(feedbackText);


                    } else if (qData.type === 'multiple') {
                        const selectedOptions = quizForm.querySelectorAll(`input[name="question_${index}"]:checked`);
                        const selectedValues = Array.from(selectedOptions).map(input => input.value);
                        const correctAnswers = qData.correctAnswers || []; // Default to empty array if missing
                        isAnswered = selectedOptions.length > 0; // True if at least one option was selected

                        // Check if the selected options exactly match the correct answers
                        isCorrect = isAnswered && // Must have selected something
                            selectedValues.length === correctAnswers.length &&
                            correctAnswers.every(answer => selectedValues.includes(answer));

                        const options = questionElement.querySelectorAll(`input[name="question_${index}"]`);
                        options.forEach(optionInput => {
                            const label = optionInput.closest('label');
                             if (!label) return;
                            const isSelected = selectedValues.includes(optionInput.value);
                            const isCorrectAnswer = correctAnswers.includes(optionInput.value);
                            // Reset previous styles
                            label.classList.remove('correct-answer', 'incorrect-answer');

                            if (isCorrectAnswer) {
                                label.classList.add('correct-answer'); // Highlight all correct answers
                            }
                            if (isSelected && !isCorrectAnswer) {
                                label.classList.add('incorrect-answer'); // Highlight wrongly selected
                            }
                            // Disable input after submission
                            optionInput.disabled = true;
                        });


                        const feedbackText = document.createElement('p');
                        if (isAnswered) {
                            if (isCorrect) {
                                feedbackText.textContent = '¡Correcto!';
                                feedbackText.classList.add('feedback-correct');
                                score++;
                            } else {
                                feedbackText.textContent = `Incorrecto. Las respuestas correctas son: ${correctAnswers.join(', ')}`;
                                feedbackText.classList.add('feedback-incorrect');
                            }
                            feedbackDiv.classList.add(isCorrect ? 'bg-green-50' : 'bg-red-50');
                        } else {
                            feedbackText.textContent = `No respondida. Las respuestas correctas son: ${correctAnswers.join(', ')}`;
                            feedbackText.classList.add('feedback-incorrect');
                            feedbackDiv.classList.add('bg-yellow-50'); // Indicate unanswered
                        }
                        feedbackDiv.appendChild(feedbackText);


                    } else if (qData.type === 'matching') {
                        const dropZones = questionElement.querySelectorAll('.drop-zone');
                        let correctMatchesCount = 0;
                        const totalMatches = (qData.terms || []).length; // Handle missing terms array
                        let answeredMatchesCount = 0; // Count how many definitions have a term dropped on them

                        const feedbackList = document.createElement('ul');
                        feedbackList.classList.add('list-disc', 'list-inside', 'ml-4', 'mt-2');

                        dropZones.forEach(zone => {
                            const droppedItem = zone.querySelector('div[id^="term_"]'); // More specific selector
                            const definition = zone.dataset.definition;
                             if (!definition) return; // Skip if zone is broken

                            // Reset styles
                            zone.classList.remove('correct-answer', 'incorrect-answer', 'matched');

                            if (droppedItem) {
                                answeredMatchesCount++;
                                // Reset styles
                                droppedItem.classList.remove('correct-answer', 'incorrect-answer');
                                const term = droppedItem.textContent;
                                const isMatchCorrect = qData.correctMatches && qData.correctMatches[term] === definition;

                                const feedbackItem = document.createElement('li');

                                if (isMatchCorrect) {
                                    correctMatchesCount++;
                                    droppedItem.classList.add('correct-answer');
                                    zone.classList.add('correct-answer');
                                    feedbackItem.classList.add('correct-match-feedback');
                                    feedbackItem.textContent = `Correcto: ${term} -> ${definition}`;
                                } else {
                                    droppedItem.classList.add('incorrect-answer');
                                    zone.classList.add('incorrect-answer');
                                    feedbackItem.classList.add('incorrect-match-feedback');
                                    let correctTermForDef = "N/A";
                                    if (qData.correctMatches) {
                                        correctTermForDef = Object.keys(qData.correctMatches).find(key => qData.correctMatches[key] === definition) || "N/A";
                                    }
                                    feedbackItem.textContent = `Incorrecto: "${term}" no coincide con "${definition}". (Correcto era: "${correctTermForDef}")`;
                                }
                                feedbackList.appendChild(feedbackItem);

                                // Make items non-draggable after submission
                                droppedItem.draggable = false;
                                droppedItem.classList.remove('draggable');
                                // Remove touch listeners too
                                droppedItem.removeEventListener('touchstart', handleTouchStart);
                                droppedItem.removeEventListener('touchmove', handleTouchMove);
                                droppedItem.removeEventListener('touchend', handleTouchEnd);


                            } else {
                                // Handle unmatched definitions (no item dropped here)
                                const feedbackItem = document.createElement('li');
                                feedbackItem.classList.add('incorrect-match-feedback');
                                let correctTermForDef = "N/A";
                                if (qData.correctMatches) {
                                    correctTermForDef = Object.keys(qData.correctMatches).find(key => qData.correctMatches[key] === definition) || "N/A";
                                }
                                feedbackItem.textContent = `No respondido: La definición "${definition}" debía unirse con "${correctTermForDef}".`;
                                feedbackList.appendChild(feedbackItem);
                                zone.classList.add('incorrect-answer'); // Style unanswered zone
                            }
                             // Make zones non-interactive
                             zone.removeEventListener('dragover', handleDragOver);
                             zone.removeEventListener('dragleave', handleDragLeave);
                             zone.removeEventListener('drop', handleDrop);
                        });

                        // Make remaining draggable terms (still in the terms list) non-draggable and mark as incorrect
                        questionElement.querySelectorAll('.terms-container-js > div[id^="term_"]').forEach(termEl => {
                            termEl.draggable = false;
                            termEl.classList.remove('draggable');
                            termEl.classList.add('incorrect-answer'); // Style unplaced terms
                             // Remove touch listeners too
                            termEl.removeEventListener('touchstart', handleTouchStart);
                            termEl.removeEventListener('touchmove', handleTouchMove);
                            termEl.removeEventListener('touchend', handleTouchEnd);

                            const feedbackItem = document.createElement('li');
                            feedbackItem.classList.add('incorrect-match-feedback');
                            feedbackItem.textContent = `No respondido: El término "${termEl.textContent}" no fue unido.`;
                            feedbackList.appendChild(feedbackItem);
                        });


                        feedbackDiv.appendChild(feedbackList);

                        // Award points only if all matches are correct
                        isCorrect = totalMatches > 0 && correctMatchesCount === totalMatches; // Ensure totalMatches > 0
                        // Answered if at least one match attempted OR not all terms are left in the initial list
                        isAnswered = answeredMatchesCount > 0 || (questionElement.querySelectorAll('.terms-container-js > div[id^="term_"]').length < totalMatches && totalMatches > 0);

                        if (isCorrect) {
                            score++;
                            feedbackDiv.classList.add('bg-green-50');
                        } else if (isAnswered) { // If attempted but not fully correct
                            feedbackDiv.classList.add('bg-red-50');
                        } else { // If completely unanswered
                            feedbackDiv.classList.add('bg-yellow-50');
                        }
                    }
                } catch (evalError) {
                     console.error(`Error evaluating question ${index + 1}:`, evalError, qData);
                     const errorFeedback = document.createElement('p');
                     errorFeedback.classList.add('feedback-incorrect', 'font-bold');
                     errorFeedback.textContent = "Error al evaluar esta pregunta. Revisa su formato en el editor.";
                     feedbackDiv.appendChild(errorFeedback);
                     feedbackDiv.classList.add('bg-red-100');
                }

                feedbackElement.appendChild(feedbackDiv);
            });

            // Adjust total if some questions were skipped due to errors
             if (totalQuestions <= 0) {
                 scoreElement.textContent = "No se pudieron evaluar preguntas.";
             } else {
                scoreElement.textContent = `Tu puntuación: ${score} de ${totalQuestions}`;
             }
            resultsContainer.classList.remove('hidden');
            // Disable submit button after showing results
            const submitButton = quizForm.querySelector('button[type="submit"]');
             if (submitButton) {
                submitButton.disabled = true;
                submitButton.classList.add('opacity-50', 'cursor-not-allowed');
             }

            window.scrollTo({ top: resultsContainer.offsetTop - 20, behavior: 'smooth' }); // Scroll smoothly to results
        }

        // Function to save quiz data from editor to localStorage
        function saveQuizData() {
            const jsonString = jsonEditor.value;
            try {
                const parsedData = JSON.parse(jsonString);
                 // Basic validation
                 if (!Array.isArray(parsedData)) {
                     throw new Error("El formato debe ser un array JSON: [...]");
                 }
                // Optionally add more validation for each question object structure here

                localStorage.setItem('quizData', jsonString);
                currentQuizData = parsedData; // Update the global variable
                saveStatus.textContent = '¡Guardado con éxito!';
                saveStatus.className = 'text-sm text-green-600';
                // Optionally reload the quiz UI immediately
                // loadQuizUI();
            } catch (error) {
                console.error("Error saving JSON data:", error);
                saveStatus.textContent = `Error al guardar: ${error.message}. Revisa la sintaxis JSON.`;
                saveStatus.className = 'text-sm text-red-600';
            }
             // Clear status message after a few seconds
            setTimeout(() => { saveStatus.textContent = ''; }, 5000);
        }

         // Function to reset quiz data to default
        function resetQuizData() {
            if (confirm("¿Estás seguro de que quieres restablecer las preguntas a las predeterminadas? Perderás tus cambios guardados.")) {
                localStorage.removeItem('quizData'); // Remove custom data
                loadQuizData(); // This will now load defaults and save them
                loadQuizUI(); // Reload the quiz display
                saveStatus.textContent = 'Preguntas restablecidas a las predeterminadas.';
                saveStatus.className = 'text-sm text-blue-600';
                setTimeout(() => { saveStatus.textContent = ''; }, 3000);
            }
        }

        // Function to handle tab switching
        function switchTab(event) {
            const clickedTab = event.target.closest('.tab-button');
            if (!clickedTab) return;

            const tabId = clickedTab.dataset.tab;

            // Update button styles
            tabButtons.forEach(button => {
                button.classList.toggle('active', button.dataset.tab === tabId);
            });

            // Update content visibility
            tabContents.forEach(content => {
                content.classList.toggle('active', content.id === `${tabId}-tab`);
            });
        }

        // Function to render README content (simple conversion)
        function renderReadme() {
            let htmlContent = readmeContent
                .replace(/^# (.*$)/gim, '<h2>$1</h2>')        // H1 -> H2
                .replace(/^## (.*$)/gim, '<h3>$1</h3>')       // H2 -> H3
                .replace(/^### (.*$)/gim, '<h4>$1</h4>')      // H3 -> H4
                .replace(/^\* (.*$)/gim, '<li>$1</li>')       // List items
                .replace(/<\/li>\n<li>/gim, '</li><li>')      // Fix spaces between li
                .replace(/(<li>.*<\/li>)/gim, '<ul>$1</ul>')  // Wrap LIs in ULs (basic)
                .replace(/<\/ul>\n<ul>/gim, '')               // Combine adjacent ULs
                .replace(/`([^`]+)`/g, '<code>$1</code>')     // Inline code
                .replace(/```json\n([\s\S]*?)\n```/gim, '<pre><code>$1</code></pre>') // JSON code blocks
                .replace(/```javascript\n([\s\S]*?)\n```/gim, '<pre><code>$1</code></pre>') // JS code blocks
                .replace(/\*\*(.*)\*\*/g, '<strong>$1</strong>') // Bold
                .replace(/\*(.*)\*/g, '<em>$1</em>')           // Italic
                .replace(/\n/g, '<br>');                     // Newlines (simple approach)

             // Refine list wrapping - wrap consecutive LIs properly
             htmlContent = htmlContent.replace(/<br><ul>/g, '<ul>').replace(/<\/ul><br>/g, '</ul>');
             let finalHtml = '';
             let inList = false;
             htmlContent.split('<br>').forEach(line => {
                 if (line.startsWith('<ul><li>')) {
                     if (!inList) {
                         finalHtml += '<ul>';
                         inList = true;
                     }
                     finalHtml += line.substring(4, line.length - 5); // Add only the li content
                 } else {
                     if (inList) {
                         finalHtml += '</ul>';
                         inList = false;
                     }
                     finalHtml += line + (line.match(/<\/?(h[2-4]|p|ul|li|pre)>$/) ? '' : '<br>'); // Add BR only if not ending with block tag
                 }
             });
             if (inList) finalHtml += '</ul>'; // Close list if it was the last element

             // Remove redundant <br> tags
             finalHtml = finalHtml.replace(/<br>\s*<br>/g, '<br>');
             finalHtml = finalHtml.replace(/<br><\/(h[2-4]|p|ul|pre)>/g, '</$1>');
             finalHtml = finalHtml.replace(/<(h[2-4]|p|ul|pre)><br>/g, '<$1>');


            explanationContent.innerHTML = finalHtml;
        }


        // --- Event Listeners ---
        quizForm.addEventListener('submit', (e) => {
            e.preventDefault();
            showResults();
        });

        retryButton.addEventListener('click', () => {
            loadQuizUI(); // Reloads the UI with current questions, shuffled
            window.scrollTo(0, 0); // Scroll to top
        });

        saveJsonButton.addEventListener('click', saveQuizData);
        resetJsonButton.addEventListener('click', resetQuizData);

        tabButtons.forEach(button => {
            button.addEventListener('click', switchTab);
        });


        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            loadQuizData(); // Load data from storage or defaults
            loadQuizUI();   // Build the quiz interface
            renderReadme(); // Populate the help tab
             // Ensure the correct tab is shown on load (Quiz tab)
             tabButtons.forEach(button => button.classList.remove('active'));
             tabContents.forEach(content => content.classList.remove('active'));
             document.querySelector('.tab-button[data-tab="quiz"]').classList.add('active');
             document.getElementById('quiz-tab').classList.add('active');
        });


    </script>

</body>

</html>
